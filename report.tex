\documentclass{cslthse-msc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{makeidx}
\usepackage{graphicx}
\usepackage[titletoc, header, page]{appendix}

\usepackage{hyperref}
\usepackage{pdfpages}

\usepackage{enumitem}
\usepackage{subfig}
\usepackage{float}
\usepackage{listings}
\input{listings-modelica.cfg}

%\geometry{showframe}

\author{
	Erik Hedblom \\
	{\normalsize \href{mailto:hedblom.e@gmail.com}{\texttt{hedblom.e@gmail.com}}}
	\and
	Kasper Rundquist \\
	{\normalsize \href{mailto:kasper.rundquist@gmail.com}{\texttt{kasper.rundquist@gmail.com}}}
}

\title{Safe regression test selection using static analysis}
%\subtitle{A {\LaTeX} class}
\company{Modelon AB}
\supervisors{Johan Ylikiiskilä, \href{mailto:johan.ylikiiskila@modelon.com}{\texttt{johan.ylikiiskila@modelon.com}}}{Jonatan Kämpe, \href{mailto:jonathan.kampe@modelon.com}{\texttt{jonathan.kampe@modelon.com}}}{Niklas Fors, \href{mailto:niklas.fors@cs.lth.se}{\texttt{niklas.fors@cs.lth.se}}}%\supervisor{Niklas Fors, \href{mailto:niklas.fors@cs.lth.se}{\texttt{niklas.fors@cs.lth.se}}}
\examiner{Görel Hedin, \href{mailto:gorel.hedin@cs.lth.se}{\texttt{gorel.hedin@cs.lth.se}}}

\date{\today}
%\date{January 16, 2015}

\acknowledgements{
If you want to thank people, do it here, on a separate right-hand page. Both the U.S. \textit{acknowledgments} and the British \textit{acknowledgements} spellings are acceptable.
}

\theabstract{
This document describes the Master's Thesis format for the theses carried out at 
the Department of Computer Science, Lund University. 

Your abstract should capture, in English, the whole thesis with focus on the problem and solution in 150 words. It should be placed on a separate right-hand page, with an additional \textit{1cm} margin on both left and right. Avoid acronyms, footnotes, and references in the abstract if possible.

Leave a \textit{2cm} vertical space after the abstract and provide a few keywords relevant for your report. Use five to six words, of which at most two should be from the title.
}

\keywords{Regression Test Selection, Modelica}

\divisionoflabor{
}

%% Only used to display font sizes
\makeatletter
\newcommand\thefontsize[1]{{#1 \f@size pt\par}}
\makeatother
%%%%%%%%%%


\begin{document}
\makefrontmatter
\chapter[Introduction]{Introduction}

\section{Motivation / Background}
During software development, when a change is integrated into a project all previous testing have to be rerun. Test suites usually accumulates over time and regression testing can therefore be very time consuming. Depending on the change some or most of the test may be unrelated to the change and by excluding unrelated tests significant time savings could be achieved. ~\cite{DUMMY}


Det är viktig att testa mjukvara under utvecklingen för säkerställa att mjukvaran fungerar korrekt. När mjukvaran uppdateras måste testfall som redan testats utföras igen för att kontrollera att allt som fungerade innan uppdatering fortfarande fungerar efter. Det kan vara väldigt tidskrävande att köra samtliga test. Det finns därför mycket tid att spara om det går att utesluta test som garanterat inte har påverkas. För språket Modelica finns det inget verktyg för detta och det är därför intressant att utveckla ett.

\section{Problem Description / Aim / Goal}

The aim of this project is too reduce testing times for Modelica projects without loss of quality. This will be done by developing and implementing a method to exclude tests in a test suite unaffected by a specific change. Regression testing can then be performed with a reduced test suite without compromising quality. 

\chapter[Background]{Background}
\section{Regression Testing}
Regression tests are used to make sure that regression dose not occur. Software regression is when something that did work before do not work as expected due to a change.
\section{Test Selection}
\begin{itemize}
	\item What is test selection?
	\item Different approaches
A safe Regression Test Selection (RTS) method will select all tests that produce a new result after a specific change. A safe RTS method is equivalent to running all tests. For a RTS method to be useful the RTS algorithm should run in less time than it takes to run the excluded tests.
\end{itemize}

\section{Modelica?}
\begin{itemize}
	\item What is Modelica?
Modelica is an object-oriented language and is used for physical models and simulation. 

The output of a Modelica compilation process is code to be compiled, in our case C-code.~\cite{aakesson2008development}
	\item How can we perform test selection for Modelica?
	\item SourceTree, InstanceTree, FlatTree
\end{itemize}

\section{JastAdd}
JastAdd is a system based on reference attribute grammars, for extensible implementation of compilers. An Abstract Syntax Tree (AST) is used to represent a program. Attribute Grammars is amethod for declerativly defining computations on an AST. A node in an AST can have a synthezied attribute or an inherited attribute. An attribue is defined by an equation. A synthezied attribyte is defined in the node, an inherired attribute is defined in an ancestor node.A JastAdd specification is used to create an object-oriented framework.~\cite{aakesson2008development}

Collection attributes are defined by partial definitions in a number of arbitrary nodes. A node that have a partial definition of a collection attribute contributes to the value of the collection attribute. A collection attribute is usually a set where the empty set is the initial value of the collection attribute. The contributors, the nodes that contributes to the collection attribute, can for example contribute by adding elements to the set.~\cite{magnusson2007extending}

\chapter[Implementation]{Implementation}

\section{Dependency analysis}

This dependency analysis is intended for source tree analysis.

The dependency model we have developed have two types of dependencies, parent and access dependencies. Parent dependencies are dependencies that occur due to Modelicas lookup and scoping rules. This means that classes depend on the class they are defined in, their parent. consider the following code:

\lstinputlisting[language=modelica]{modelica/parent1.mo}
\begin{figure}
    \centering
    \includegraphics[]{EPS-graphs/parent1.pdf}
  \caption{The dependency graph}
  \label{fig:parent1graph}
\end{figure}

D has a dependency to A.k since it accesses the constant k. This is not a parent dependency and we will leave it for now. D also has dependencies to B and C due to Modelicas scoping and lookup rules. If k is redefined in either B or C, the reference to k in D will refer to k in C or B instead. To handle this type of dependency we say that a class has a dependency to its parent class.

Another way to think about it is to consider what happens if a parent is removed. The class class can no longer be accessed since the path to it is broken. This will causes the compilation of the class to fail. The corresponding dependency graph is found in figure \ref{fig:parent1graph}.

Access dependencies are all the other dependencies, dependencies created by accesses. However, one access can create one, many or no dependencies. If an access have path each part of the path creates a dependency. This is an example this.
\lstinputlisting[language=modelica]{modelica/import1.mo}
The class E have an access P.A.B.D referring to P.C.D. The access also creates dependencies to P, P.A and P.A.B. If P, P.A or P.A.B is removed E will fail to build since the path P.A.B.D is broken. Another case to consider is if B redefines D, D in E will then have changed.


\subsection{Rules}
\begin{enumerate}
\item A class depends on its parent class. 
\item A class depends on all accesses within it. (TODO: What about Redeclare?)
\item A class depends on all classes in the paths of its accesses
\item A class depends on all classes defined in a accessed class
\end{enumerate}


In figure \ref{fig:extends}, class C is the accessed class in the immediate subtree of class A. Class B is in the path to the accessed class. Class E is an subclass to class C.
Example:
\begin{figure}[H]
    \centering
    \subfloat{{\includegraphics[]{EPS-graphs/extends.eps}}}
    \qquad
    \subfloat{{\lstinputlisting[language=modelica]{modelica/extends.mo}}}
    \caption{Extends Graph}
    \label{fig:extends}
\end{figure}
Dependency rules
\begin{figure}[H]
    \centering
    \subfloat{{\includegraphics[]{EPS-graphs/ParentExample.eps}}}
    \qquad
    \subfloat{{\lstinputlisting[language=modelica]{modelica/parentExample.mo}}}
    \caption{Parent graph}
    \label{fig:parentGraph}
\end{figure}

There is a constant k defined in package A. If we define a constant k in model B, the k accessed in C will be k defined in model B. Therefore we need a dependency from C to B.

If the constant k in package A is changed it will affect model C. Therefore we need a dependency from C to A. With rule number 1 we get dependencies from C to B and from B to A. So we have an indirect dependency from C to A, figure \ref{fig:parentGraph}.

\begin{figure}[H]
    \centering
    \subfloat{{\includegraphics[]{EPS-graphs/GraphA.eps}}}
    \qquad
    \subfloat{{\lstinputlisting[language=modelica]{modelica/exampleA.mo}}}
    \caption{Graph A}
    \label{fig:GraphA}
\end{figure}

When we create an instance of A in model E, we want dependencies from E to A and everything in A, see figure \ref{fig:GraphA}. We want to have a dependency from E to the subtree with A as a root, in this case the subtree consists of the nodes P.A, P.A.B and P.A.B.f.

\begin{figure}[H]
    \centering
    \subfloat{{\includegraphics[]{EPS-graphs/DotAccess.eps}}}
    \qquad
    \subfloat{{\lstinputlisting[language=modelica]{modelica/DotAccess.mo}}}
    \subfloat{{\lstinputlisting[language=modelica]{modelica/DotAccessC.mo}}}
    \caption{Dot Access}
    \label{fig:dotAccess}
\end{figure}

To find the dependency from model D to function f in C, we want to add dependencies from all the parts of an Dot access. We want dependencies from D to A, A.B and C.f.
\subsection{Incremental updating}

\section{Test selection}

\chapter[Evaluation]{Evaluation}
\begin{itemize}
	\item Savings
	\item Precision
\end{itemize}

\chapter[Future Work]{Future Work}

\chapter[Discussion]{Discussion}


\begin{itemize}
	\item Validity
	\item Analysis granularity
\end{itemize}

\section{Related Work}
A master thesis similar to this one has previously been done at LTH ~\cite{kampe2012dependroid}. In the previously master thesis JastAdd was used to decrease the cost for testing of Android projects ~\cite{DUMMY}. There is research done on test selection. A method for safe RTS for Java has been developed before, that has many similarities with the method we are developing for Modelica. 

Studies have been conducted to investigate at which granularity dependency analysis pays off the most and how much percision it can have with out getting to expensive ~\cite{DBLP:conf/sigsoft/LegunsenHSLZM16}. It has also been done work in other techniques to achieve shorter time for testing, including dynamic test selection.

Det har tidigare gjorts ett liknande examensarbete på LTH. Där användes JastAdd för att minska kostnaden för testning av Android projekt. Det finns även forskning på området. Nästan precis samma sak som vi ska göra har gjorts tidigare men för Java ~\cite{DBLP:conf/pppj/OqvistHM16}. Utöver detta har det även tidigare undersökts hur finkornig en beroendeanalys kan vara utan att den blir för dyr ~\cite{DBLP:conf/sigsoft/LegunsenHSLZM16}. Det finns även arbete inom andra tekniker för att uppnå kortare test tider, till exempel dynamiskt testurval.

\makebibliography{thebib}

\begin{appendices}
\chapter{About This Document}
\end{appendices}


\end{document}